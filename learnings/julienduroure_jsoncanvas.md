├── .gitignore
├── Cargo.lock
├── Cargo.toml
├── LICENSE
├── README.md
├── bin
    └── serial.rs
└── src
    ├── color.rs
    ├── edge.rs
    ├── id.rs
    ├── jsoncanvas.rs
    ├── lib.rs
    └── node
        ├── file.rs
        ├── group.rs
        ├── link.rs
        ├── mod.rs
        └── text.rs


/.gitignore:
--------------------------------------------------------------------------------
1 | /target
2 | 


--------------------------------------------------------------------------------
/Cargo.lock:
--------------------------------------------------------------------------------
  1 | # This file is automatically @generated by Cargo.
  2 | # It is not intended for manual editing.
  3 | version = 3
  4 | 
  5 | [[package]]
  6 | name = "ambassador"
  7 | version = "0.3.6"
  8 | source = "registry+https://github.com/rust-lang/crates.io-index"
  9 | checksum = "a2362d85b9d773d0d6ec70d6cc8f27ddef81edd11b05bc4e18281e4993b6e6d6"
 10 | dependencies = [
 11 |  "itertools",
 12 |  "proc-macro2",
 13 |  "quote",
 14 |  "syn 1.0.109",
 15 | ]
 16 | 
 17 | [[package]]
 18 | name = "android-tzdata"
 19 | version = "0.1.1"
 20 | source = "registry+https://github.com/rust-lang/crates.io-index"
 21 | checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"
 22 | 
 23 | [[package]]
 24 | name = "android_system_properties"
 25 | version = "0.1.5"
 26 | source = "registry+https://github.com/rust-lang/crates.io-index"
 27 | checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
 28 | dependencies = [
 29 |  "libc",
 30 | ]
 31 | 
 32 | [[package]]
 33 | name = "arrayvec"
 34 | version = "0.7.4"
 35 | source = "registry+https://github.com/rust-lang/crates.io-index"
 36 | checksum = "96d30a06541fbafbc7f82ed10c06164cfbd2c401138f6addd8404629c4b16711"
 37 | 
 38 | [[package]]
 39 | name = "autocfg"
 40 | version = "1.1.0"
 41 | source = "registry+https://github.com/rust-lang/crates.io-index"
 42 | checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"
 43 | 
 44 | [[package]]
 45 | name = "base64"
 46 | version = "0.21.7"
 47 | source = "registry+https://github.com/rust-lang/crates.io-index"
 48 | checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"
 49 | 
 50 | [[package]]
 51 | name = "bumpalo"
 52 | version = "3.15.4"
 53 | source = "registry+https://github.com/rust-lang/crates.io-index"
 54 | checksum = "7ff69b9dd49fd426c69a0db9fc04dd934cdb6645ff000864d98f7e2af8830eaa"
 55 | 
 56 | [[package]]
 57 | name = "cc"
 58 | version = "1.0.90"
 59 | source = "registry+https://github.com/rust-lang/crates.io-index"
 60 | checksum = "8cd6604a82acf3039f1144f54b8eb34e91ffba622051189e71b781822d5ee1f5"
 61 | 
 62 | [[package]]
 63 | name = "cfg-if"
 64 | version = "1.0.0"
 65 | source = "registry+https://github.com/rust-lang/crates.io-index"
 66 | checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 67 | 
 68 | [[package]]
 69 | name = "chrono"
 70 | version = "0.4.35"
 71 | source = "registry+https://github.com/rust-lang/crates.io-index"
 72 | checksum = "8eaf5903dcbc0a39312feb77df2ff4c76387d591b9fc7b04a238dcf8bb62639a"
 73 | dependencies = [
 74 |  "android-tzdata",
 75 |  "iana-time-zone",
 76 |  "num-traits",
 77 |  "serde",
 78 |  "windows-targets",
 79 | ]
 80 | 
 81 | [[package]]
 82 | name = "core-foundation-sys"
 83 | version = "0.8.6"
 84 | source = "registry+https://github.com/rust-lang/crates.io-index"
 85 | checksum = "06ea2b9bc92be3c2baa9334a323ebca2d6f074ff852cd1d7b11064035cd3868f"
 86 | 
 87 | [[package]]
 88 | name = "darling"
 89 | version = "0.20.8"
 90 | source = "registry+https://github.com/rust-lang/crates.io-index"
 91 | checksum = "54e36fcd13ed84ffdfda6f5be89b31287cbb80c439841fe69e04841435464391"
 92 | dependencies = [
 93 |  "darling_core",
 94 |  "darling_macro",
 95 | ]
 96 | 
 97 | [[package]]
 98 | name = "darling_core"
 99 | version = "0.20.8"
100 | source = "registry+https://github.com/rust-lang/crates.io-index"
101 | checksum = "9c2cf1c23a687a1feeb728783b993c4e1ad83d99f351801977dd809b48d0a70f"
102 | dependencies = [
103 |  "fnv",
104 |  "ident_case",
105 |  "proc-macro2",
106 |  "quote",
107 |  "strsim",
108 |  "syn 2.0.52",
109 | ]
110 | 
111 | [[package]]
112 | name = "darling_macro"
113 | version = "0.20.8"
114 | source = "registry+https://github.com/rust-lang/crates.io-index"
115 | checksum = "a668eda54683121533a393014d8692171709ff57a7d61f187b6e782719f8933f"
116 | dependencies = [
117 |  "darling_core",
118 |  "quote",
119 |  "syn 2.0.52",
120 | ]
121 | 
122 | [[package]]
123 | name = "deranged"
124 | version = "0.3.11"
125 | source = "registry+https://github.com/rust-lang/crates.io-index"
126 | checksum = "b42b6fa04a440b495c8b04d0e71b707c585f83cb9cb28cf8cd0d976c315e31b4"
127 | dependencies = [
128 |  "powerfmt",
129 |  "serde",
130 | ]
131 | 
132 | [[package]]
133 | name = "either"
134 | version = "1.10.0"
135 | source = "registry+https://github.com/rust-lang/crates.io-index"
136 | checksum = "11157ac094ffbdde99aa67b23417ebdd801842852b500e395a45a9c0aac03e4a"
137 | 
138 | [[package]]
139 | name = "equivalent"
140 | version = "1.0.1"
141 | source = "registry+https://github.com/rust-lang/crates.io-index"
142 | checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"
143 | 
144 | [[package]]
145 | name = "fnv"
146 | version = "1.0.7"
147 | source = "registry+https://github.com/rust-lang/crates.io-index"
148 | checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
149 | 
150 | [[package]]
151 | name = "form_urlencoded"
152 | version = "1.2.1"
153 | source = "registry+https://github.com/rust-lang/crates.io-index"
154 | checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
155 | dependencies = [
156 |  "percent-encoding",
157 | ]
158 | 
159 | [[package]]
160 | name = "getrandom"
161 | version = "0.2.12"
162 | source = "registry+https://github.com/rust-lang/crates.io-index"
163 | checksum = "190092ea657667030ac6a35e305e62fc4dd69fd98ac98631e5d3a2b1575a12b5"
164 | dependencies = [
165 |  "cfg-if",
166 |  "libc",
167 |  "wasi",
168 | ]
169 | 
170 | [[package]]
171 | name = "hashbrown"
172 | version = "0.12.3"
173 | source = "registry+https://github.com/rust-lang/crates.io-index"
174 | checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"
175 | 
176 | [[package]]
177 | name = "hashbrown"
178 | version = "0.14.3"
179 | source = "registry+https://github.com/rust-lang/crates.io-index"
180 | checksum = "290f1a1d9242c78d09ce40a5e87e7554ee637af1351968159f4952f028f75604"
181 | 
182 | [[package]]
183 | name = "hex"
184 | version = "0.4.3"
185 | source = "registry+https://github.com/rust-lang/crates.io-index"
186 | checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"
187 | 
188 | [[package]]
189 | name = "hex_color"
190 | version = "3.0.0"
191 | source = "registry+https://github.com/rust-lang/crates.io-index"
192 | checksum = "d37f101bf4c633f7ca2e4b5e136050314503dd198e78e325ea602c327c484ef0"
193 | dependencies = [
194 |  "arrayvec",
195 |  "rand",
196 |  "serde",
197 | ]
198 | 
199 | [[package]]
200 | name = "iana-time-zone"
201 | version = "0.1.60"
202 | source = "registry+https://github.com/rust-lang/crates.io-index"
203 | checksum = "e7ffbb5a1b541ea2561f8c41c087286cc091e21e556a4f09a8f6cbf17b69b141"
204 | dependencies = [
205 |  "android_system_properties",
206 |  "core-foundation-sys",
207 |  "iana-time-zone-haiku",
208 |  "js-sys",
209 |  "wasm-bindgen",
210 |  "windows-core",
211 | ]
212 | 
213 | [[package]]
214 | name = "iana-time-zone-haiku"
215 | version = "0.1.2"
216 | source = "registry+https://github.com/rust-lang/crates.io-index"
217 | checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
218 | dependencies = [
219 |  "cc",
220 | ]
221 | 
222 | [[package]]
223 | name = "ident_case"
224 | version = "1.0.1"
225 | source = "registry+https://github.com/rust-lang/crates.io-index"
226 | checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"
227 | 
228 | [[package]]
229 | name = "idna"
230 | version = "0.5.0"
231 | source = "registry+https://github.com/rust-lang/crates.io-index"
232 | checksum = "634d9b1461af396cad843f47fdba5597a4f9e6ddd4bfb6ff5d85028c25cb12f6"
233 | dependencies = [
234 |  "unicode-bidi",
235 |  "unicode-normalization",
236 | ]
237 | 
238 | [[package]]
239 | name = "indexmap"
240 | version = "1.9.3"
241 | source = "registry+https://github.com/rust-lang/crates.io-index"
242 | checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
243 | dependencies = [
244 |  "autocfg",
245 |  "hashbrown 0.12.3",
246 |  "serde",
247 | ]
248 | 
249 | [[package]]
250 | name = "indexmap"
251 | version = "2.2.5"
252 | source = "registry+https://github.com/rust-lang/crates.io-index"
253 | checksum = "7b0b929d511467233429c45a44ac1dcaa21ba0f5ba11e4879e6ed28ddb4f9df4"
254 | dependencies = [
255 |  "equivalent",
256 |  "hashbrown 0.14.3",
257 |  "serde",
258 | ]
259 | 
260 | [[package]]
261 | name = "itertools"
262 | version = "0.10.5"
263 | source = "registry+https://github.com/rust-lang/crates.io-index"
264 | checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
265 | dependencies = [
266 |  "either",
267 | ]
268 | 
269 | [[package]]
270 | name = "itoa"
271 | version = "1.0.10"
272 | source = "registry+https://github.com/rust-lang/crates.io-index"
273 | checksum = "b1a46d1a171d865aa5f83f92695765caa047a9b4cbae2cbf37dbd613a793fd4c"
274 | 
275 | [[package]]
276 | name = "js-sys"
277 | version = "0.3.69"
278 | source = "registry+https://github.com/rust-lang/crates.io-index"
279 | checksum = "29c15563dc2726973df627357ce0c9ddddbea194836909d655df6a75d2cf296d"
280 | dependencies = [
281 |  "wasm-bindgen",
282 | ]
283 | 
284 | [[package]]
285 | name = "jsoncanvas"
286 | version = "0.1.6"
287 | dependencies = [
288 |  "ambassador",
289 |  "hex_color",
290 |  "serde",
291 |  "serde_json",
292 |  "serde_with",
293 |  "thiserror",
294 |  "url",
295 | ]
296 | 
297 | [[package]]
298 | name = "libc"
299 | version = "0.2.153"
300 | source = "registry+https://github.com/rust-lang/crates.io-index"
301 | checksum = "9c198f91728a82281a64e1f4f9eeb25d82cb32a5de251c6bd1b5154d63a8e7bd"
302 | 
303 | [[package]]
304 | name = "log"
305 | version = "0.4.21"
306 | source = "registry+https://github.com/rust-lang/crates.io-index"
307 | checksum = "90ed8c1e510134f979dbc4f070f87d4313098b704861a105fe34231c70a3901c"
308 | 
309 | [[package]]
310 | name = "num-conv"
311 | version = "0.1.0"
312 | source = "registry+https://github.com/rust-lang/crates.io-index"
313 | checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"
314 | 
315 | [[package]]
316 | name = "num-traits"
317 | version = "0.2.18"
318 | source = "registry+https://github.com/rust-lang/crates.io-index"
319 | checksum = "da0df0e5185db44f69b44f26786fe401b6c293d1907744beaa7fa62b2e5a517a"
320 | dependencies = [
321 |  "autocfg",
322 | ]
323 | 
324 | [[package]]
325 | name = "once_cell"
326 | version = "1.19.0"
327 | source = "registry+https://github.com/rust-lang/crates.io-index"
328 | checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"
329 | 
330 | [[package]]
331 | name = "percent-encoding"
332 | version = "2.3.1"
333 | source = "registry+https://github.com/rust-lang/crates.io-index"
334 | checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"
335 | 
336 | [[package]]
337 | name = "powerfmt"
338 | version = "0.2.0"
339 | source = "registry+https://github.com/rust-lang/crates.io-index"
340 | checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"
341 | 
342 | [[package]]
343 | name = "ppv-lite86"
344 | version = "0.2.17"
345 | source = "registry+https://github.com/rust-lang/crates.io-index"
346 | checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"
347 | 
348 | [[package]]
349 | name = "proc-macro2"
350 | version = "1.0.79"
351 | source = "registry+https://github.com/rust-lang/crates.io-index"
352 | checksum = "e835ff2298f5721608eb1a980ecaee1aef2c132bf95ecc026a11b7bf3c01c02e"
353 | dependencies = [
354 |  "unicode-ident",
355 | ]
356 | 
357 | [[package]]
358 | name = "quote"
359 | version = "1.0.35"
360 | source = "registry+https://github.com/rust-lang/crates.io-index"
361 | checksum = "291ec9ab5efd934aaf503a6466c5d5251535d108ee747472c3977cc5acc868ef"
362 | dependencies = [
363 |  "proc-macro2",
364 | ]
365 | 
366 | [[package]]
367 | name = "rand"
368 | version = "0.8.5"
369 | source = "registry+https://github.com/rust-lang/crates.io-index"
370 | checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
371 | dependencies = [
372 |  "libc",
373 |  "rand_chacha",
374 |  "rand_core",
375 | ]
376 | 
377 | [[package]]
378 | name = "rand_chacha"
379 | version = "0.3.1"
380 | source = "registry+https://github.com/rust-lang/crates.io-index"
381 | checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
382 | dependencies = [
383 |  "ppv-lite86",
384 |  "rand_core",
385 | ]
386 | 
387 | [[package]]
388 | name = "rand_core"
389 | version = "0.6.4"
390 | source = "registry+https://github.com/rust-lang/crates.io-index"
391 | checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
392 | dependencies = [
393 |  "getrandom",
394 | ]
395 | 
396 | [[package]]
397 | name = "ryu"
398 | version = "1.0.17"
399 | source = "registry+https://github.com/rust-lang/crates.io-index"
400 | checksum = "e86697c916019a8588c99b5fac3cead74ec0b4b819707a682fd4d23fa0ce1ba1"
401 | 
402 | [[package]]
403 | name = "serde"
404 | version = "1.0.197"
405 | source = "registry+https://github.com/rust-lang/crates.io-index"
406 | checksum = "3fb1c873e1b9b056a4dc4c0c198b24c3ffa059243875552b2bd0933b1aee4ce2"
407 | dependencies = [
408 |  "serde_derive",
409 | ]
410 | 
411 | [[package]]
412 | name = "serde_derive"
413 | version = "1.0.197"
414 | source = "registry+https://github.com/rust-lang/crates.io-index"
415 | checksum = "7eb0b34b42edc17f6b7cac84a52a1c5f0e1bb2227e997ca9011ea3dd34e8610b"
416 | dependencies = [
417 |  "proc-macro2",
418 |  "quote",
419 |  "syn 2.0.52",
420 | ]
421 | 
422 | [[package]]
423 | name = "serde_json"
424 | version = "1.0.114"
425 | source = "registry+https://github.com/rust-lang/crates.io-index"
426 | checksum = "c5f09b1bd632ef549eaa9f60a1f8de742bdbc698e6cee2095fc84dde5f549ae0"
427 | dependencies = [
428 |  "itoa",
429 |  "ryu",
430 |  "serde",
431 | ]
432 | 
433 | [[package]]
434 | name = "serde_with"
435 | version = "3.7.0"
436 | source = "registry+https://github.com/rust-lang/crates.io-index"
437 | checksum = "ee80b0e361bbf88fd2f6e242ccd19cfda072cb0faa6ae694ecee08199938569a"
438 | dependencies = [
439 |  "base64",
440 |  "chrono",
441 |  "hex",
442 |  "indexmap 1.9.3",
443 |  "indexmap 2.2.5",
444 |  "serde",
445 |  "serde_derive",
446 |  "serde_json",
447 |  "serde_with_macros",
448 |  "time",
449 | ]
450 | 
451 | [[package]]
452 | name = "serde_with_macros"
453 | version = "3.7.0"
454 | source = "registry+https://github.com/rust-lang/crates.io-index"
455 | checksum = "6561dc161a9224638a31d876ccdfefbc1df91d3f3a8342eddb35f055d48c7655"
456 | dependencies = [
457 |  "darling",
458 |  "proc-macro2",
459 |  "quote",
460 |  "syn 2.0.52",
461 | ]
462 | 
463 | [[package]]
464 | name = "strsim"
465 | version = "0.10.0"
466 | source = "registry+https://github.com/rust-lang/crates.io-index"
467 | checksum = "73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623"
468 | 
469 | [[package]]
470 | name = "syn"
471 | version = "1.0.109"
472 | source = "registry+https://github.com/rust-lang/crates.io-index"
473 | checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
474 | dependencies = [
475 |  "proc-macro2",
476 |  "quote",
477 |  "unicode-ident",
478 | ]
479 | 
480 | [[package]]
481 | name = "syn"
482 | version = "2.0.52"
483 | source = "registry+https://github.com/rust-lang/crates.io-index"
484 | checksum = "b699d15b36d1f02c3e7c69f8ffef53de37aefae075d8488d4ba1a7788d574a07"
485 | dependencies = [
486 |  "proc-macro2",
487 |  "quote",
488 |  "unicode-ident",
489 | ]
490 | 
491 | [[package]]
492 | name = "thiserror"
493 | version = "1.0.58"
494 | source = "registry+https://github.com/rust-lang/crates.io-index"
495 | checksum = "03468839009160513471e86a034bb2c5c0e4baae3b43f79ffc55c4a5427b3297"
496 | dependencies = [
497 |  "thiserror-impl",
498 | ]
499 | 
500 | [[package]]
501 | name = "thiserror-impl"
502 | version = "1.0.58"
503 | source = "registry+https://github.com/rust-lang/crates.io-index"
504 | checksum = "c61f3ba182994efc43764a46c018c347bc492c79f024e705f46567b418f6d4f7"
505 | dependencies = [
506 |  "proc-macro2",
507 |  "quote",
508 |  "syn 2.0.52",
509 | ]
510 | 
511 | [[package]]
512 | name = "time"
513 | version = "0.3.34"
514 | source = "registry+https://github.com/rust-lang/crates.io-index"
515 | checksum = "c8248b6521bb14bc45b4067159b9b6ad792e2d6d754d6c41fb50e29fefe38749"
516 | dependencies = [
517 |  "deranged",
518 |  "itoa",
519 |  "num-conv",
520 |  "powerfmt",
521 |  "serde",
522 |  "time-core",
523 |  "time-macros",
524 | ]
525 | 
526 | [[package]]
527 | name = "time-core"
528 | version = "0.1.2"
529 | source = "registry+https://github.com/rust-lang/crates.io-index"
530 | checksum = "ef927ca75afb808a4d64dd374f00a2adf8d0fcff8e7b184af886c3c87ec4a3f3"
531 | 
532 | [[package]]
533 | name = "time-macros"
534 | version = "0.2.17"
535 | source = "registry+https://github.com/rust-lang/crates.io-index"
536 | checksum = "7ba3a3ef41e6672a2f0f001392bb5dcd3ff0a9992d618ca761a11c3121547774"
537 | dependencies = [
538 |  "num-conv",
539 |  "time-core",
540 | ]
541 | 
542 | [[package]]
543 | name = "tinyvec"
544 | version = "1.6.0"
545 | source = "registry+https://github.com/rust-lang/crates.io-index"
546 | checksum = "87cc5ceb3875bb20c2890005a4e226a4651264a5c75edb2421b52861a0a0cb50"
547 | dependencies = [
548 |  "tinyvec_macros",
549 | ]
550 | 
551 | [[package]]
552 | name = "tinyvec_macros"
553 | version = "0.1.1"
554 | source = "registry+https://github.com/rust-lang/crates.io-index"
555 | checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
556 | 
557 | [[package]]
558 | name = "unicode-bidi"
559 | version = "0.3.15"
560 | source = "registry+https://github.com/rust-lang/crates.io-index"
561 | checksum = "08f95100a766bf4f8f28f90d77e0a5461bbdb219042e7679bebe79004fed8d75"
562 | 
563 | [[package]]
564 | name = "unicode-ident"
565 | version = "1.0.12"
566 | source = "registry+https://github.com/rust-lang/crates.io-index"
567 | checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"
568 | 
569 | [[package]]
570 | name = "unicode-normalization"
571 | version = "0.1.23"
572 | source = "registry+https://github.com/rust-lang/crates.io-index"
573 | checksum = "a56d1686db2308d901306f92a263857ef59ea39678a5458e7cb17f01415101f5"
574 | dependencies = [
575 |  "tinyvec",
576 | ]
577 | 
578 | [[package]]
579 | name = "url"
580 | version = "2.5.0"
581 | source = "registry+https://github.com/rust-lang/crates.io-index"
582 | checksum = "31e6302e3bb753d46e83516cae55ae196fc0c309407cf11ab35cc51a4c2a4633"
583 | dependencies = [
584 |  "form_urlencoded",
585 |  "idna",
586 |  "percent-encoding",
587 |  "serde",
588 | ]
589 | 
590 | [[package]]
591 | name = "wasi"
592 | version = "0.11.0+wasi-snapshot-preview1"
593 | source = "registry+https://github.com/rust-lang/crates.io-index"
594 | checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
595 | 
596 | [[package]]
597 | name = "wasm-bindgen"
598 | version = "0.2.92"
599 | source = "registry+https://github.com/rust-lang/crates.io-index"
600 | checksum = "4be2531df63900aeb2bca0daaaddec08491ee64ceecbee5076636a3b026795a8"
601 | dependencies = [
602 |  "cfg-if",
603 |  "wasm-bindgen-macro",
604 | ]
605 | 
606 | [[package]]
607 | name = "wasm-bindgen-backend"
608 | version = "0.2.92"
609 | source = "registry+https://github.com/rust-lang/crates.io-index"
610 | checksum = "614d787b966d3989fa7bb98a654e369c762374fd3213d212cfc0251257e747da"
611 | dependencies = [
612 |  "bumpalo",
613 |  "log",
614 |  "once_cell",
615 |  "proc-macro2",
616 |  "quote",
617 |  "syn 2.0.52",
618 |  "wasm-bindgen-shared",
619 | ]
620 | 
621 | [[package]]
622 | name = "wasm-bindgen-macro"
623 | version = "0.2.92"
624 | source = "registry+https://github.com/rust-lang/crates.io-index"
625 | checksum = "a1f8823de937b71b9460c0c34e25f3da88250760bec0ebac694b49997550d726"
626 | dependencies = [
627 |  "quote",
628 |  "wasm-bindgen-macro-support",
629 | ]
630 | 
631 | [[package]]
632 | name = "wasm-bindgen-macro-support"
633 | version = "0.2.92"
634 | source = "registry+https://github.com/rust-lang/crates.io-index"
635 | checksum = "e94f17b526d0a461a191c78ea52bbce64071ed5c04c9ffe424dcb38f74171bb7"
636 | dependencies = [
637 |  "proc-macro2",
638 |  "quote",
639 |  "syn 2.0.52",
640 |  "wasm-bindgen-backend",
641 |  "wasm-bindgen-shared",
642 | ]
643 | 
644 | [[package]]
645 | name = "wasm-bindgen-shared"
646 | version = "0.2.92"
647 | source = "registry+https://github.com/rust-lang/crates.io-index"
648 | checksum = "af190c94f2773fdb3729c55b007a722abb5384da03bc0986df4c289bf5567e96"
649 | 
650 | [[package]]
651 | name = "windows-core"
652 | version = "0.52.0"
653 | source = "registry+https://github.com/rust-lang/crates.io-index"
654 | checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
655 | dependencies = [
656 |  "windows-targets",
657 | ]
658 | 
659 | [[package]]
660 | name = "windows-targets"
661 | version = "0.52.4"
662 | source = "registry+https://github.com/rust-lang/crates.io-index"
663 | checksum = "7dd37b7e5ab9018759f893a1952c9420d060016fc19a472b4bb20d1bdd694d1b"
664 | dependencies = [
665 |  "windows_aarch64_gnullvm",
666 |  "windows_aarch64_msvc",
667 |  "windows_i686_gnu",
668 |  "windows_i686_msvc",
669 |  "windows_x86_64_gnu",
670 |  "windows_x86_64_gnullvm",
671 |  "windows_x86_64_msvc",
672 | ]
673 | 
674 | [[package]]
675 | name = "windows_aarch64_gnullvm"
676 | version = "0.52.4"
677 | source = "registry+https://github.com/rust-lang/crates.io-index"
678 | checksum = "bcf46cf4c365c6f2d1cc93ce535f2c8b244591df96ceee75d8e83deb70a9cac9"
679 | 
680 | [[package]]
681 | name = "windows_aarch64_msvc"
682 | version = "0.52.4"
683 | source = "registry+https://github.com/rust-lang/crates.io-index"
684 | checksum = "da9f259dd3bcf6990b55bffd094c4f7235817ba4ceebde8e6d11cd0c5633b675"
685 | 
686 | [[package]]
687 | name = "windows_i686_gnu"
688 | version = "0.52.4"
689 | source = "registry+https://github.com/rust-lang/crates.io-index"
690 | checksum = "b474d8268f99e0995f25b9f095bc7434632601028cf86590aea5c8a5cb7801d3"
691 | 
692 | [[package]]
693 | name = "windows_i686_msvc"
694 | version = "0.52.4"
695 | source = "registry+https://github.com/rust-lang/crates.io-index"
696 | checksum = "1515e9a29e5bed743cb4415a9ecf5dfca648ce85ee42e15873c3cd8610ff8e02"
697 | 
698 | [[package]]
699 | name = "windows_x86_64_gnu"
700 | version = "0.52.4"
701 | source = "registry+https://github.com/rust-lang/crates.io-index"
702 | checksum = "5eee091590e89cc02ad514ffe3ead9eb6b660aedca2183455434b93546371a03"
703 | 
704 | [[package]]
705 | name = "windows_x86_64_gnullvm"
706 | version = "0.52.4"
707 | source = "registry+https://github.com/rust-lang/crates.io-index"
708 | checksum = "77ca79f2451b49fa9e2af39f0747fe999fcda4f5e241b2898624dca97a1f2177"
709 | 
710 | [[package]]
711 | name = "windows_x86_64_msvc"
712 | version = "0.52.4"
713 | source = "registry+https://github.com/rust-lang/crates.io-index"
714 | checksum = "32b752e52a2da0ddfbdbcc6fceadfeede4c939ed16d13e648833a61dfb611ed8"
715 | 


--------------------------------------------------------------------------------
/Cargo.toml:
--------------------------------------------------------------------------------
 1 | [package]
 2 | name = "jsoncanvas"
 3 | version = "0.1.6"
 4 | authors = ["Julien Duroure <julien.duroure@gmail.com>"]
 5 | license = "MIT"
 6 | edition = "2021"
 7 | description = "Library for creating and manipulating jsoncanvas data"
 8 | repository = "https://github.com/julienduroure/jsoncanvas"
 9 | 
10 | # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
11 | 
12 | [dependencies]
13 | serde = { version = "1.0.197", features = ["derive"] }
14 | serde_json = "1.0.114"
15 | serde_with = "3.7"
16 | url = { version = "2.5.0", features = ["serde"]}
17 | hex_color = { version = "3.0.0", features = ["serde"] }
18 | ambassador = "0.3.6"
19 | thiserror = "1.0.58"
20 | 
21 | [[bin]]
22 | name = "serial"
23 | path = "bin/serial.rs"
24 | 


--------------------------------------------------------------------------------
/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2024 Julien Duroure
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/README.md:
--------------------------------------------------------------------------------
1 | # JsonCanvas
2 | 
3 | JsonCanvas is a simple library for creating and manipulating jsoncanvas files.
4 | The specification for the jsoncanvas file format can be found [here](https://jsoncanvas.org/)
5 | 
6 | # License
7 | 
8 | This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
9 | 


--------------------------------------------------------------------------------
/bin/serial.rs:
--------------------------------------------------------------------------------
  1 | use hex_color::HexColor;
  2 | use jsoncanvas::color::{Color, PresetColor};
  3 | use jsoncanvas::edge::{Edge, End, Side};
  4 | use jsoncanvas::node::{
  5 |     Background, BackgroundStyle, FileNode, GroupNode, LinkNode, Node, TextNode,
  6 | };
  7 | use jsoncanvas::JsonCanvas;
  8 | use std::path::PathBuf;
  9 | use url::Url;
 10 | 
 11 | fn main() {
 12 |     ///////////////////////////// Serialization /////////////////////////////
 13 | 
 14 |     // Color
 15 |     let color1 = Color::Preset(PresetColor::Red);
 16 |     let color2 = Color::Color(HexColor::parse("#ff0000").unwrap());
 17 | 
 18 |     let serialized_color1 = serde_json::to_string(&color1).unwrap();
 19 |     let serialized_color2 = serde_json::to_string(&color2).unwrap();
 20 | 
 21 |     println!("serialized1 = {}", serialized_color1);
 22 |     println!("serialized2 = {}", serialized_color2);
 23 | 
 24 |     // Text Node
 25 |     let node1: Node = Node::Text(TextNode::new(
 26 |         "id".parse().unwrap(),
 27 |         0,
 28 |         0,
 29 |         100,
 30 |         100,
 31 |         Some(Color::Preset(PresetColor::Red)),
 32 |         "This is a test".to_string(),
 33 |     ));
 34 | 
 35 |     // File Node
 36 |     let node2: Node = Node::File(FileNode::new(
 37 |         "id2".parse().unwrap(),
 38 |         0,
 39 |         0,
 40 |         100,
 41 |         100,
 42 |         Some(Color::Preset(PresetColor::Red)),
 43 |         PathBuf::from("dir/to/path/file.png"),
 44 |         None,
 45 |     ));
 46 |     let node3: Node = Node::File(FileNode::new(
 47 |         "id3".parse().unwrap(),
 48 |         0,
 49 |         0,
 50 |         100,
 51 |         100,
 52 |         Some(color1),
 53 |         PathBuf::from("dir/to/path/file.png"),
 54 |         Some("#here".parse().unwrap()),
 55 |     ));
 56 | 
 57 |     // Link Node
 58 |     let node4: Node = Node::Link(LinkNode::new(
 59 |         "id4".parse().unwrap(),
 60 |         0,
 61 |         0,
 62 |         100,
 63 |         100,
 64 |         Some(Color::Preset(PresetColor::Red)),
 65 |         Url::parse("https://julienduroure.com").unwrap(),
 66 |     ));
 67 | 
 68 |     // Group Node
 69 |     let node5: Node = Node::Group(GroupNode::new(
 70 |         "id5".parse().unwrap(),
 71 |         0,
 72 |         0,
 73 |         100,
 74 |         100,
 75 |         Some(color2),
 76 |         Some("Label".to_string()),
 77 |         None,
 78 |     ));
 79 |     let node6: Node = Node::Group(GroupNode::new(
 80 |         "id6".parse().unwrap(),
 81 |         0,
 82 |         0,
 83 |         100,
 84 |         100,
 85 |         None,
 86 |         None,
 87 |         None,
 88 |     ));
 89 |     let node7: Node = Node::Group(GroupNode::new(
 90 |         "id7".parse().unwrap(),
 91 |         0,
 92 |         0,
 93 |         100,
 94 |         100,
 95 |         None,
 96 |         None,
 97 |         Some(Background::new(PathBuf::from("path/to/image.png"), None)),
 98 |     ));
 99 |     let node8: Node = Node::Group(GroupNode::new(
100 |         "id8".parse().unwrap(),
101 |         0,
102 |         0,
103 |         100,
104 |         100,
105 |         None,
106 |         None,
107 |         Some(Background::new(
108 |             PathBuf::from("path/to/image.png"),
109 |             Some(BackgroundStyle::Cover),
110 |         )),
111 |     ));
112 | 
113 |     let serialized_node1: String = serde_json::to_string(&node1).unwrap();
114 |     let serialized_node2 = serde_json::to_string(&node2).unwrap();
115 |     let serialized_node3 = serde_json::to_string(&node3).unwrap();
116 |     let serialized_node4 = serde_json::to_string(&node4).unwrap();
117 |     let serialized_node5 = serde_json::to_string(&node5).unwrap();
118 |     let serialized_node6 = serde_json::to_string(&node6).unwrap();
119 |     let serialized_node7 = serde_json::to_string(&node7).unwrap();
120 |     let serialized_node8 = serde_json::to_string(&node8).unwrap();
121 | 
122 |     println!("serialized node 1= {}", serialized_node1);
123 |     println!("serialized node 2= {}", serialized_node2);
124 |     println!("serialized node 3= {}", serialized_node3);
125 |     println!("serialized node 4= {}", serialized_node4);
126 |     println!("serialized node 5= {}", serialized_node5);
127 |     println!("serialized node 6= {}", serialized_node6);
128 |     println!("serialized node 7= {}", serialized_node7);
129 |     println!("serialized node 8= {}", serialized_node8);
130 | 
131 |     // Edge
132 | 
133 |     let edge1 = Edge::new(
134 |         "edge1".parse().unwrap(),
135 |         "id".parse().unwrap(),
136 |         None,
137 |         None,
138 |         "id2".parse().unwrap(),
139 |         Some(Side::Left),
140 |         Some(End::Arrow),
141 |         None,
142 |         None,
143 |     );
144 |     let edge2 = Edge::new(
145 |         "edge2".parse().unwrap(),
146 |         "id3".parse().unwrap(),
147 |         None,
148 |         None,
149 |         "id4".parse().unwrap(),
150 |         Some(Side::Left),
151 |         Some(End::Arrow),
152 |         Some(Color::Preset(PresetColor::Cyan)),
153 |         Some("edge label".to_string()),
154 |     );
155 | 
156 |     let serialized_edge1 = serde_json::to_string(&edge1).unwrap();
157 |     let serialized_edge2 = serde_json::to_string(&edge2).unwrap();
158 | 
159 |     println!("serialized edge 1= {}", serialized_edge1);
160 |     println!("serialized edge 2= {}", serialized_edge2);
161 | 
162 |     // JSON Canvas
163 |     let mut canvas = JsonCanvas::default();
164 | 
165 |     let empty_canvas = canvas.to_string();
166 |     println!("empty canvas = {}", empty_canvas);
167 |     canvas = empty_canvas.parse().unwrap();
168 | 
169 |     canvas.add_node(node1).unwrap();
170 |     canvas.add_node(node2).unwrap();
171 |     canvas.add_node(node3).unwrap();
172 |     canvas.add_node(node4).unwrap();
173 |     canvas.add_node(node5).unwrap();
174 |     canvas.add_node(node6).unwrap();
175 |     canvas.add_node(node7).unwrap();
176 |     canvas.add_node(node8).unwrap();
177 | 
178 |     canvas.add_edge(edge1).unwrap();
179 |     canvas.add_edge(edge2).unwrap();
180 | 
181 |     let serialized_canvas = canvas.to_string();
182 | 
183 |     println!("serialized canvas = {}", serialized_canvas);
184 | 
185 |     ///////////////////////////// Deserialization /////////////////////////////
186 | 
187 |     // let deserialized_node1: Node = serde_json::from_str(&serialized_node1).unwrap();
188 |     // println!("deserialized node 1= {:?}", deserialized_node1);
189 | 
190 |     // let deseralied_edge1: Edge = serde_json::from_str(&serialized_edge1).unwrap();
191 |     // println!("deserialized edge 1= {:?}", deseralied_edge1);
192 | 
193 |     let jsoncanvas_deserialized: JsonCanvas = serialized_canvas.parse().unwrap();
194 |     println!("deserialized canvas = {:?}", jsoncanvas_deserialized);
195 | }
196 | 


--------------------------------------------------------------------------------
/src/color.rs:
--------------------------------------------------------------------------------
 1 | pub use hex_color::HexColor;
 2 | use serde::{Deserialize, Serialize};
 3 | 
 4 | #[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
 5 | pub enum PresetColor {
 6 |     #[serde(rename = "1")]
 7 |     Red = 1,
 8 |     #[serde(rename = "2")]
 9 |     Orange = 2,
10 |     #[serde(rename = "3")]
11 |     Yellow = 3,
12 |     #[serde(rename = "4")]
13 |     Green = 4,
14 |     #[serde(rename = "5")]
15 |     Cyan = 5,
16 |     #[serde(rename = "6")]
17 |     Purple = 6,
18 | }
19 | 
20 | #[derive(Debug, Serialize, Deserialize, PartialEq)]
21 | #[serde(untagged)]
22 | pub enum Color {
23 |     Preset(PresetColor),
24 |     Color(HexColor),
25 | }
26 | 
27 | impl From<PresetColor> for Color {
28 |     fn from(value: PresetColor) -> Self {
29 |         Self::Preset(value)
30 |     }
31 | }
32 | 
33 | impl From<HexColor> for Color {
34 |     fn from(value: HexColor) -> Self {
35 |         Self::Color(value)
36 |     }
37 | }
38 | 
39 | #[cfg(test)]
40 | mod tests {
41 |     use super::*;
42 | 
43 |     #[test]
44 |     fn preset_deser() {
45 |         let preset: PresetColor = serde_json::from_str("\"1\"").unwrap();
46 |         assert_eq!(preset, PresetColor::Red);
47 |     }
48 | 
49 |     #[test]
50 |     fn color_preset_deser() {
51 |         let color: Color = serde_json::from_str("\"2\"").unwrap();
52 |         assert_eq!(color, Color::Preset(PresetColor::Orange));
53 |     }
54 | 
55 |     #[test]
56 |     fn color_rgb_deser() {
57 |         let color: Color = serde_json::from_str("\"#FF0000\"").unwrap();
58 |         assert_eq!(color, Color::Color(HexColor::rgb(255, 0, 0)))
59 |     }
60 | 
61 |     #[test]
62 |     fn color_ser() {
63 |         assert_eq!(
64 |             serde_json::to_string(&Color::Preset(PresetColor::Yellow)).unwrap(),
65 |             "\"3\""
66 |         );
67 |         assert_eq!(
68 |             serde_json::to_string(&Color::Color(HexColor::rgb(255, 0, 0))).unwrap(),
69 |             "\"#FF0000\""
70 |         );
71 |     }
72 | }
73 | 


--------------------------------------------------------------------------------
/src/edge.rs:
--------------------------------------------------------------------------------
  1 | use serde::{Deserialize, Serialize};
  2 | 
  3 | use crate::{color::Color, EdgeId, NodeId};
  4 | 
  5 | #[derive(Debug, Serialize, Deserialize)]
  6 | #[serde(rename_all = "camelCase")]
  7 | pub struct Edge {
  8 |     pub id: EdgeId,
  9 |     pub from_node: NodeId,
 10 |     #[serde(skip_serializing_if = "Option::is_none")]
 11 |     from_side: Option<Side>,
 12 |     #[serde(skip_serializing_if = "Option::is_none")]
 13 |     from_end: Option<End>,
 14 |     pub to_node: NodeId,
 15 |     #[serde(skip_serializing_if = "Option::is_none")]
 16 |     to_side: Option<Side>,
 17 |     #[serde(skip_serializing_if = "Option::is_none")]
 18 |     to_end: Option<End>,
 19 |     #[serde(skip_serializing_if = "Option::is_none")]
 20 |     color: Option<crate::color::Color>,
 21 |     #[serde(skip_serializing_if = "Option::is_none")]
 22 |     label: Option<String>,
 23 | }
 24 | 
 25 | pub type Terminus = (NodeId, Option<Side>, Option<End>);
 26 | 
 27 | impl Edge {
 28 |     #[allow(clippy::too_many_arguments)]
 29 |     pub fn new(
 30 |         id: EdgeId,
 31 |         from_node: NodeId,
 32 |         from_side: Option<Side>,
 33 |         from_end: Option<End>,
 34 |         to_node: NodeId,
 35 |         to_side: Option<Side>,
 36 |         to_end: Option<End>,
 37 |         color: Option<crate::color::Color>,
 38 |         label: Option<String>,
 39 |     ) -> Edge {
 40 |         Edge {
 41 |             id,
 42 |             from_node,
 43 |             from_side,
 44 |             from_end,
 45 |             to_node,
 46 |             to_side,
 47 |             to_end,
 48 |             color,
 49 |             label,
 50 |         }
 51 |     }
 52 | 
 53 |     pub fn id(&self) -> &EdgeId {
 54 |         &self.id
 55 |     }
 56 | 
 57 |     pub fn from_node(&self) -> &NodeId {
 58 |         &self.from_node
 59 |     }
 60 | 
 61 |     pub fn from_side(&self) -> Option<&Side> {
 62 |         self.from_side.as_ref()
 63 |     }
 64 | 
 65 |     pub fn from_end(&self) -> Option<&End> {
 66 |         self.from_end.as_ref()
 67 |     }
 68 | 
 69 |     pub fn to_node(&self) -> &NodeId {
 70 |         &self.to_node
 71 |     }
 72 | 
 73 |     pub fn to_side(&self) -> Option<&Side> {
 74 |         self.to_side.as_ref()
 75 |     }
 76 | 
 77 |     pub fn to_end(&self) -> Option<&End> {
 78 |         self.to_end.as_ref()
 79 |     }
 80 | 
 81 |     pub fn color(&self) -> Option<&Color> {
 82 |         self.color.as_ref()
 83 |     }
 84 | 
 85 |     pub fn label(&self) -> Option<&String> {
 86 |         self.label.as_ref()
 87 |     }
 88 | 
 89 |     pub fn set_color(&mut self, color: Color) -> &mut Self {
 90 |         self.color = Some(color);
 91 |         self
 92 |     }
 93 | 
 94 |     pub fn remove_color(&mut self) -> Option<Color> {
 95 |         std::mem::take(&mut self.color)
 96 |     }
 97 | 
 98 |     pub fn set_label(&mut self, label: String) -> &mut Self {
 99 |         self.label = Some(label);
100 |         self
101 |     }
102 | 
103 |     pub fn remove_label(&mut self) -> Option<String> {
104 |         std::mem::take(&mut self.label)
105 |     }
106 | 
107 |     pub fn set_from(&mut self, node: NodeId, side: Option<Side>, end: Option<End>) -> Terminus {
108 |         (
109 |             std::mem::replace(&mut self.from_node, node),
110 |             std::mem::replace(&mut self.from_side, side),
111 |             std::mem::replace(&mut self.from_end, end),
112 |         )
113 |     }
114 | 
115 |     pub fn set_to(&mut self, node: NodeId, side: Option<Side>, end: Option<End>) -> Terminus {
116 |         (
117 |             std::mem::replace(&mut self.to_node, node),
118 |             std::mem::replace(&mut self.to_side, side),
119 |             std::mem::replace(&mut self.to_end, end),
120 |         )
121 |     }
122 | }
123 | 
124 | #[derive(Debug, Serialize, Deserialize)]
125 | #[serde(rename_all = "camelCase")]
126 | pub enum Side {
127 |     Top,
128 |     Left,
129 |     Right,
130 |     Bottom,
131 | }
132 | 
133 | #[derive(Debug, Serialize, Deserialize)]
134 | #[serde(rename_all = "camelCase")]
135 | pub enum End {
136 |     None,
137 |     Arrow,
138 | }
139 | 


--------------------------------------------------------------------------------
/src/id.rs:
--------------------------------------------------------------------------------
 1 | use std::{fmt::Display, str::FromStr};
 2 | 
 3 | use serde::{Deserialize, Serialize};
 4 | 
 5 | #[derive(Debug, thiserror::Error)]
 6 | #[error("ID is empty")]
 7 | pub struct EmptyId;
 8 | 
 9 | macro_rules! id_type {
10 |     ($($name: ident),+) => { $(
11 |         #[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize, Deserialize)]
12 |         #[repr(transparent)]
13 |         #[serde(transparent)]
14 |         pub struct $name(pub(self) String);
15 | 
16 |         impl $name {
17 |             pub fn into_inner(self) -> String {
18 |                 self.0
19 |             }
20 | 
21 |             pub fn as_str(&self) -> &str {
22 |                 &self.0
23 |             }
24 |         }
25 | 
26 |         impl Display for $name {
27 |             fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
28 |                 self.0.fmt(f)
29 |             }
30 |         }
31 | 
32 |         impl FromStr for $name {
33 |             type Err = EmptyId;
34 | 
35 |             fn from_str(value: &str) -> Result<Self, Self::Err> {
36 |                 if value.is_empty() {
37 |                     Err(EmptyId)
38 |                 } else {
39 |                     Ok(Self(value.to_string()))
40 |                 }
41 |             }
42 |         }
43 | 
44 |         impl TryFrom<String> for $name {
45 |             type Error = EmptyId;
46 | 
47 |             fn try_from(value: String) -> Result<Self, Self::Error> {
48 |                 if value.is_empty() {
49 |                     Err(EmptyId)
50 |                 } else {
51 |                     Ok(Self(value))
52 |                 }
53 |             }
54 |         }
55 |     )+};
56 | }
57 | 
58 | id_type!(NodeId, EdgeId);
59 | 


--------------------------------------------------------------------------------
/src/jsoncanvas.rs:
--------------------------------------------------------------------------------
  1 | use std::collections::HashMap;
  2 | use std::fmt::{Display, Formatter};
  3 | use std::str::FromStr;
  4 | 
  5 | use crate::edge::Edge;
  6 | use crate::id::EmptyId;
  7 | use crate::node::GenericNodeInfo;
  8 | use crate::node::Node;
  9 | use crate::EdgeId;
 10 | use crate::NodeId;
 11 | 
 12 | use serde::{Deserialize, Deserializer, Serialize, Serializer};
 13 | use serde_json;
 14 | use thiserror::Error;
 15 | 
 16 | #[derive(Debug, Error)]
 17 | pub enum JsonCanvasError {
 18 |     #[error("Node {0} already exists")]
 19 |     NodeExists(NodeId),
 20 |     #[error("Edge {0} already exists")]
 21 |     EdgeExists(EdgeId),
 22 |     #[error("Node {0} does not exist")]
 23 |     NodeNotExists(NodeId),
 24 |     #[error(transparent)]
 25 |     ParseError(#[from] serde_json::Error),
 26 |     #[error(transparent)]
 27 |     EmptyId(#[from] EmptyId),
 28 | }
 29 | 
 30 | /// JsonCanvas
 31 | ///
 32 | /// Main struct for the canvas
 33 | ///
 34 | #[derive(Debug, Serialize, Deserialize, Default)]
 35 | pub struct JsonCanvas {
 36 |     #[serde(
 37 |         serialize_with = "serialize_as_vec_node",
 38 |         deserialize_with = "deserialize_as_map_node"
 39 |     )]
 40 |     #[serde(skip_serializing_if = "HashMap::is_empty", default)]
 41 |     nodes: HashMap<NodeId, Node>,
 42 |     #[serde(
 43 |         serialize_with = "serialize_as_vec_edge",
 44 |         deserialize_with = "deserialize_as_map_edge"
 45 |     )]
 46 |     #[serde(skip_serializing_if = "HashMap::is_empty", default)]
 47 |     edges: HashMap<EdgeId, Edge>,
 48 | }
 49 | fn serialize_as_vec_node<S>(data: &HashMap<NodeId, Node>, serializer: S) -> Result<S::Ok, S::Error>
 50 | where
 51 |     S: Serializer,
 52 | {
 53 |     let vec: Vec<&Node> = data.values().collect();
 54 |     vec.serialize(serializer)
 55 | }
 56 | 
 57 | fn deserialize_as_map_node<'de, D>(deserializer: D) -> Result<HashMap<NodeId, Node>, D::Error>
 58 | where
 59 |     D: Deserializer<'de>,
 60 | {
 61 |     let vec: Vec<Node> = Vec::deserialize(deserializer)?;
 62 |     let map: HashMap<_, _> = vec
 63 |         .into_iter()
 64 |         .map(|node| (node.id().clone(), node))
 65 |         .collect();
 66 |     Ok(map)
 67 | }
 68 | 
 69 | fn serialize_as_vec_edge<S>(data: &HashMap<EdgeId, Edge>, serializer: S) -> Result<S::Ok, S::Error>
 70 | where
 71 |     S: Serializer,
 72 | {
 73 |     let vec: Vec<&Edge> = data.values().collect();
 74 |     vec.serialize(serializer)
 75 | }
 76 | 
 77 | fn deserialize_as_map_edge<'de, D>(deserializer: D) -> Result<HashMap<EdgeId, Edge>, D::Error>
 78 | where
 79 |     D: Deserializer<'de>,
 80 | {
 81 |     let vec: Vec<Edge> = Vec::deserialize(deserializer)?;
 82 |     let map: HashMap<_, _> = vec
 83 |         .into_iter()
 84 |         .map(|node| (node.id().clone(), node))
 85 |         .collect();
 86 |     Ok(map)
 87 | }
 88 | 
 89 | impl JsonCanvas {
 90 |     pub fn add_node(&mut self, node: Node) -> Result<(), JsonCanvasError> {
 91 |         if self.nodes.contains_key(node.id()) {
 92 |             return Err(JsonCanvasError::NodeExists(node.id().clone()));
 93 |         }
 94 |         self.nodes.insert(node.id().clone(), node);
 95 |         Ok(())
 96 |     }
 97 | 
 98 |     pub fn add_edge(&mut self, edge: Edge) -> Result<(), JsonCanvasError> {
 99 |         if self.edges.contains_key(edge.id()) {
100 |             return Err(JsonCanvasError::EdgeExists(edge.id().clone()));
101 |         }
102 | 
103 |         if !self.nodes.contains_key(edge.from_node()) {
104 |             return Err(JsonCanvasError::NodeNotExists(edge.from_node().clone()));
105 |         }
106 | 
107 |         if !self.nodes.contains_key(edge.to_node()) {
108 |             return Err(JsonCanvasError::NodeNotExists(edge.to_node().clone()));
109 |         }
110 | 
111 |         self.edges.insert(edge.id().clone(), edge);
112 |         Ok(())
113 |     }
114 | 
115 |     pub fn get_node(&mut self, id: NodeId) -> Option<&mut Node> {
116 |         self.nodes.get_mut(&id)
117 |     }
118 | 
119 |     pub fn get_edge(&mut self, id: EdgeId) -> Option<&mut Edge> {
120 |         self.edges.get_mut(&id)
121 |     }
122 | 
123 |     pub fn get_nodes(&self) -> &HashMap<NodeId, Node> {
124 |         &self.nodes
125 |     }
126 | 
127 |     pub fn get_mut_nodes(&mut self) -> &mut HashMap<NodeId, Node> {
128 |         &mut self.nodes
129 |     }
130 | 
131 |     pub fn get_edges(&self) -> &HashMap<EdgeId, Edge> {
132 |         &self.edges
133 |     }
134 | 
135 |     pub fn get_mut_edges(&mut self) -> &mut HashMap<EdgeId, Edge> {
136 |         &mut self.edges
137 |     }
138 | }
139 | 
140 | impl FromStr for JsonCanvas {
141 |     type Err = JsonCanvasError;
142 | 
143 |     fn from_str(s: &str) -> Result<Self, Self::Err> {
144 |         Ok(serde_json::from_str(s)?)
145 |     }
146 | }
147 | 
148 | impl Display for JsonCanvas {
149 |     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
150 |         write!(f, "{}", serde_json::to_string(self).unwrap())
151 |     }
152 | }
153 | 


--------------------------------------------------------------------------------
/src/lib.rs:
--------------------------------------------------------------------------------
  1 | //! # jsoncanvas
  2 | //!
  3 | //! `jsoncanvas` is a library for creating and manipulating JSON objects representing a canvas.
  4 | //!
  5 | //! Specification source: <https://jsoncanvas.org/>
  6 | //!
  7 | //! ## Example
  8 | //!
  9 | //! ```
 10 | //! use jsoncanvas::JsonCanvas;
 11 | //! let s: String = "{\"nodes\":[{\"id\":\"id7\",\"x\":0,\"y\":0,\"width\":100,\"height\":100,\"background\":\"path/to/image.png\",\"type\":\"group\"},{\"id\":\"id5\",\"x\":0,\"y\":0,\"width\":100,\"height\":100,\"color\":\"#ff0000\",\"label\":\"Label\",\"type\":\"group\"},{\"id\":\"id2\",\"x\":0,\"y\":0,\"width\":100,\"height\":100,\"color\":\"1\",\"file\":\"dir/to/path/file.png\",\"type\":\"file\"},{\"id\":\"id4\",\"x\":0,\"y\":0,\"width\":100,\"height\":100,\"color\":\"1\",\"url\":\"https://www.google.com\",\"type\":\"link\"},{\"id\":\"id6\",\"x\":0,\"y\":0,\"width\":100,\"height\":100,\"type\":\"group\"},{\"id\":\"id3\",\"x\":0,\"y\":0,\"width\":100,\"height\":100,\"color\":\"1\",\"file\":\"dir/to/path/file.png\",\"subpath\":\"#here\",\"type\":\"file\"},{\"id\":\"id8\",\"x\":0,\"y\":0,\"width\":100,\"height\":100,\"background\":\"path/to/image.png\",\"backgroundStyle\":\"cover\",\"type\":\"group\"},{\"id\":\"id\",\"x\":0,\"y\":0,\"width\":100,\"height\":100,\"color\":\"1\",\"text\":\"Test\",\"type\":\"text\"}],\"edges\":[{\"id\":\"edge2\",\"fromNode\":\"node3\",\"toNode\":\"node4\",\"color\":\"5\",\"label\":\"edge label\",\"toSide\":\"left\",\"toEnd\":\"arrow\"},{\"id\":\"edge1\",\"fromNode\":\"node1\",\"toNode\":\"node2\",\"toSide\":\"left\",\"toEnd\":\"arrow\"}]}".to_string();
 12 | //! let canvas: JsonCanvas = s.parse().unwrap();
 13 | //!
 14 | //! let _s = canvas.to_string();
 15 | //! ```
 16 | //!
 17 | //! ## Complete example
 18 | //!
 19 | //! ```
 20 | //!    use hex_color::HexColor;
 21 | //!    use jsoncanvas::color::{Color, PresetColor};
 22 | //!    use jsoncanvas::edge::{Edge, End, Side};
 23 | //!    use jsoncanvas::node::{
 24 | //!        Background, BackgroundStyle, FileNode, GroupNode, LinkNode, Node, TextNode,
 25 | //!    };
 26 | //!    use jsoncanvas::JsonCanvas;
 27 | //!    use std::path::PathBuf;
 28 | //!    use url::Url;
 29 | //!
 30 | //!    // Color
 31 | //!    let color1 = Color::Preset(PresetColor::Red);
 32 | //!    let color2 = Color::Color(HexColor::parse("#ff0000").unwrap());
 33 | //!
 34 | //!    let serialized_color1 = serde_json::to_string(&color1).unwrap();
 35 | //!    let serialized_color2 = serde_json::to_string(&color2).unwrap();
 36 | //!
 37 | //!    println!("serialized1 = {}", serialized_color1);
 38 | //!    println!("serialized2 = {}", serialized_color2);
 39 | //!
 40 | //!    // Text Node
 41 | //!    let node1: Node = Node::Text(TextNode::new(
 42 | //!        "id".parse().unwrap(),
 43 | //!        0,
 44 | //!        0,
 45 | //!        100,
 46 | //!        100,
 47 | //!        Some(Color::Preset(PresetColor::Red)),
 48 | //!        "This is a test".to_string(),
 49 | //!    ));
 50 | //!
 51 | //!    // File Node
 52 | //!    let node2: Node = Node::File(FileNode::new(
 53 | //!        "id2".parse().unwrap(),
 54 | //!        0,
 55 | //!        0,
 56 | //!        100,
 57 | //!        100,
 58 | //!        Some(Color::Preset(PresetColor::Red)),
 59 | //!        PathBuf::from("dir/to/path/file.png"),
 60 | //!        None,
 61 | //!    ));
 62 | //!    let node3: Node = Node::File(FileNode::new(
 63 | //!        "id3".parse().unwrap(),
 64 | //!        0,
 65 | //!        0,
 66 | //!        100,
 67 | //!        100,
 68 | //!        Some(color1),
 69 | //!        PathBuf::from("dir/to/path/file.png"),
 70 | //!        Some("#here".parse().unwrap()),
 71 | //!    ));
 72 | //!
 73 | //!    // Link Node
 74 | //!    let node4: Node = Node::Link(LinkNode::new(
 75 | //!        "id4".parse().unwrap(),
 76 | //!        0,
 77 | //!        0,
 78 | //!        100,
 79 | //!        100,
 80 | //!        Some(Color::Preset(PresetColor::Red)),
 81 | //!        Url::parse("https://julienduroure.com").unwrap(),
 82 | //!    ));
 83 | //!
 84 | //!    // Group Node
 85 | //!    let node5: Node = Node::Group(GroupNode::new(
 86 | //!        "id5".parse().unwrap(),
 87 | //!        0,
 88 | //!        0,
 89 | //!        100,
 90 | //!        100,
 91 | //!        Some(color2),
 92 | //!        Some("Label".to_string()),
 93 | //!        None,
 94 | //!    ));
 95 | //!    let node6: Node = Node::Group(GroupNode::new(
 96 | //!        "id6".parse().unwrap(),
 97 | //!        0,
 98 | //!        0,
 99 | //!        100,
100 | //!        100,
101 | //!        None,
102 | //!        None,
103 | //!        None,
104 | //!    ));
105 | //!    let node7: Node = Node::Group(GroupNode::new(
106 | //!        "id7".parse().unwrap(),
107 | //!        0,
108 | //!        0,
109 | //!        100,
110 | //!        100,
111 | //!        None,
112 | //!        None,
113 | //!        Some(Background::new(PathBuf::from("path/to/image.png"), None)),
114 | //!    ));
115 | //!    let node8: Node = Node::Group(GroupNode::new(
116 | //!        "id8".parse().unwrap(),
117 | //!        0,
118 | //!        0,
119 | //!        100,
120 | //!        100,
121 | //!        None,
122 | //!        None,
123 | //!        Some(Background::new(
124 | //!            PathBuf::from("path/to/image.png"),
125 | //!            Some(BackgroundStyle::Cover),
126 | //!        )),
127 | //!    ));
128 | //!
129 | //!    let serialized_node1: String = serde_json::to_string(&node1).unwrap();
130 | //!    let serialized_node2 = serde_json::to_string(&node2).unwrap();
131 | //!    let serialized_node3 = serde_json::to_string(&node3).unwrap();
132 | //!    let serialized_node4 = serde_json::to_string(&node4).unwrap();
133 | //!    let serialized_node5 = serde_json::to_string(&node5).unwrap();
134 | //!    let serialized_node6 = serde_json::to_string(&node6).unwrap();
135 | //!    let serialized_node7 = serde_json::to_string(&node7).unwrap();
136 | //!    let serialized_node8 = serde_json::to_string(&node8).unwrap();
137 | //!
138 | //!    println!("serialized node 1= {}", serialized_node1);
139 | //!    println!("serialized node 2= {}", serialized_node2);
140 | //!    println!("serialized node 3= {}", serialized_node3);
141 | //!    println!("serialized node 4= {}", serialized_node4);
142 | //!    println!("serialized node 5= {}", serialized_node5);
143 | //!    println!("serialized node 6= {}", serialized_node6);
144 | //!    println!("serialized node 7= {}", serialized_node7);
145 | //!    println!("serialized node 8= {}", serialized_node8);
146 | //!
147 | //!    // Edge
148 | //!
149 | //!    let edge1 = Edge::new(
150 | //!        "edge1".parse().unwrap(),
151 | //!        "id".parse().unwrap(),
152 | //!        None,
153 | //!        None,
154 | //!        "id2".parse().unwrap(),
155 | //!        Some(Side::Left),
156 | //!        Some(End::Arrow),
157 | //!        None,
158 | //!        None,
159 | //!    );
160 | //!    let edge2 = Edge::new(
161 | //!        "edge2".parse().unwrap(),
162 | //!        "id3".parse().unwrap(),
163 | //!        None,
164 | //!        None,
165 | //!        "id4".parse().unwrap(),
166 | //!        Some(Side::Left),
167 | //!        Some(End::Arrow),
168 | //!        Some(Color::Preset(PresetColor::Cyan)),
169 | //!        Some("edge label".to_string()),
170 | //!    );
171 | //!
172 | //!    let serialized_edge1 = serde_json::to_string(&edge1).unwrap();
173 | //!    let serialized_edge2 = serde_json::to_string(&edge2).unwrap();
174 | //!
175 | //!    println!("serialized edge 1= {}", serialized_edge1);
176 | //!    println!("serialized edge 2= {}", serialized_edge2);
177 | //!
178 | //!    // JSON Canvas
179 | //!    let mut canvas = JsonCanvas::default();
180 | //!
181 | //!    let empty_canvas = canvas.to_string();
182 | //!    println!("empty canvas = {}", empty_canvas);
183 | //!    canvas = empty_canvas.parse().unwrap();
184 | //!
185 | //!    canvas.add_node(node1).unwrap();
186 | //!    canvas.add_node(node2).unwrap();
187 | //!    canvas.add_node(node3).unwrap();
188 | //!    canvas.add_node(node4).unwrap();
189 | //!    canvas.add_node(node5).unwrap();
190 | //!    canvas.add_node(node6).unwrap();
191 | //!    canvas.add_node(node7).unwrap();
192 | //!    canvas.add_node(node8).unwrap();
193 | //!
194 | //!    canvas.add_edge(edge1).unwrap();
195 | //!    canvas.add_edge(edge2).unwrap();
196 | //!
197 | //!    let serialized_canvas = canvas.to_string();
198 | //!
199 | //!    println!("serialized canvas = {}", serialized_canvas);
200 | //!
201 | //!    let jsoncanvas_deserialized: JsonCanvas = serialized_canvas.parse().unwrap();
202 | //!    println!("deserialized canvas = {:?}", jsoncanvas_deserialized);
203 | //! ```
204 | //!
205 | //! ## Available structs
206 | //!
207 | //! ```
208 | //! use hex_color::HexColor;
209 | //! use jsoncanvas::color::{Color, PresetColor};
210 | //! use jsoncanvas::edge::{Edge, End, Side};
211 | //! use jsoncanvas::node::{
212 | //!     Background, BackgroundStyle, FileNode, GroupNode, LinkNode, Node, TextNode,
213 | //! };
214 | //! use jsoncanvas::JsonCanvas;
215 | //! use std::path::PathBuf;
216 | //! use url::Url;
217 | //! ```
218 | 
219 | // pub type NodeId = String;
220 | // pub type EdgeId = String;
221 | pub type PixelCoordinate = i64;
222 | pub type PixelDimension = u64;
223 | 
224 | pub mod color;
225 | pub mod edge;
226 | mod id;
227 | pub mod jsoncanvas;
228 | pub mod node;
229 | 
230 | pub use id::{EdgeId, NodeId};
231 | pub use jsoncanvas::JsonCanvas;
232 | pub use jsoncanvas::JsonCanvasError;
233 | pub use node::{Background, BackgroundStyle, FileNode, GroupNode, LinkNode, Node, TextNode};
234 | 
235 | #[cfg(test)]
236 | mod test {
237 |     use hex_color::HexColor;
238 | 
239 |     #[test]
240 |     fn test() {
241 |         use super::color::{Color, PresetColor};
242 |         use super::edge::{Edge, End, Side};
243 |         use super::jsoncanvas::JsonCanvas;
244 |         use super::node::{
245 |             Background, BackgroundStyle, FileNode, GroupNode, LinkNode, Node, TextNode,
246 |         };
247 |         use std::path::PathBuf;
248 |         use url::Url;
249 | 
250 |         // Color
251 |         let color1 = Color::Preset(PresetColor::Red);
252 |         let color2 = Color::Color(HexColor::parse("#ff0000").unwrap());
253 | 
254 |         // Text Node
255 |         let node1: Node = TextNode::new(
256 |             "id".parse().unwrap(),
257 |             0,
258 |             0,
259 |             100,
260 |             100,
261 |             Some(Color::Preset(PresetColor::Red)),
262 |             "This is a test".to_string(),
263 |         )
264 |         .into();
265 | 
266 |         // File Node
267 |         let node2: Node = FileNode::new(
268 |             "id2".parse().unwrap(),
269 |             0,
270 |             0,
271 |             100,
272 |             100,
273 |             Some(Color::Preset(PresetColor::Red)),
274 |             PathBuf::from("dir/to/path/file.png"),
275 |             None,
276 |         )
277 |         .into();
278 |         let node3: Node = FileNode::new(
279 |             "id3".parse().unwrap(),
280 |             0,
281 |             0,
282 |             100,
283 |             100,
284 |             Some(color1),
285 |             PathBuf::from("dir/to/path/file.png"),
286 |             Some("#here".to_string()),
287 |         )
288 |         .into();
289 | 
290 |         // Link Node
291 |         let node4: Node = LinkNode::new(
292 |             "id4".parse().unwrap(),
293 |             0,
294 |             0,
295 |             100,
296 |             100,
297 |             Some(Color::Preset(PresetColor::Red)),
298 |             Url::parse("https://julienduroure.com").unwrap(),
299 |         )
300 |         .into();
301 | 
302 |         // Group Node
303 |         let node5: Node = GroupNode::new(
304 |             "id5".parse().unwrap(),
305 |             0,
306 |             0,
307 |             100,
308 |             100,
309 |             Some(color2),
310 |             Some("Label".to_string()),
311 |             None,
312 |         )
313 |         .into();
314 |         let node6: Node =
315 |             GroupNode::new("id6".parse().unwrap(), 0, 0, 100, 100, None, None, None).into();
316 |         let node7: Node = GroupNode::new(
317 |             "id7".parse().unwrap(),
318 |             0,
319 |             0,
320 |             100,
321 |             100,
322 |             None,
323 |             None,
324 |             Some(Background::new(PathBuf::from("path/to/image.png"), None)),
325 |         )
326 |         .into();
327 |         let node8: Node = GroupNode::new(
328 |             "id8".parse().unwrap(),
329 |             0,
330 |             0,
331 |             100,
332 |             100,
333 |             None,
334 |             None,
335 |             Some(Background::new(
336 |                 PathBuf::from("path/to/image.png"),
337 |                 Some(BackgroundStyle::Cover),
338 |             )),
339 |         )
340 |         .into();
341 | 
342 |         // Edge
343 | 
344 |         let edge1 = Edge::new(
345 |             "edge1".parse().unwrap(),
346 |             "id".parse().unwrap(),
347 |             None,
348 |             None,
349 |             "id2".parse().unwrap(),
350 |             Some(Side::Left),
351 |             Some(End::Arrow),
352 |             None,
353 |             None,
354 |         );
355 |         let edge2 = Edge::new(
356 |             "edge2".parse().unwrap(),
357 |             "id3".parse().unwrap(),
358 |             None,
359 |             None,
360 |             "id4".parse().unwrap(),
361 |             Some(Side::Left),
362 |             Some(End::Arrow),
363 |             Some(Color::Preset(PresetColor::Cyan)),
364 |             Some("edge label".to_string()),
365 |         );
366 | 
367 |         // JSON Canvas
368 |         let mut canvas = JsonCanvas::default();
369 |         canvas.add_node(node1).unwrap();
370 |         canvas.add_node(node2).unwrap();
371 |         canvas.add_node(node3).unwrap();
372 |         canvas.add_node(node4).unwrap();
373 |         canvas.add_node(node5).unwrap();
374 |         canvas.add_node(node6).unwrap();
375 |         canvas.add_node(node7).unwrap();
376 |         canvas.add_node(node8).unwrap();
377 | 
378 |         canvas.add_edge(edge1).unwrap();
379 |         canvas.add_edge(edge2).unwrap();
380 | 
381 |         let serialized_canvas = canvas.to_string();
382 | 
383 |         println!("serialized canvas = {}", serialized_canvas);
384 | 
385 |         ///////////////////////////// Deserialization /////////////////////////////
386 | 
387 |         // let deserialized_node1: Node = serde_json::from_str(&serialized_node1).unwrap();
388 |         // println!("deserialized node 1= {:?}", deserialized_node1);
389 | 
390 |         // let deseralied_edge1: Edge = serde_json::from_str(&serialized_edge1).unwrap();
391 |         // println!("deserialized edge 1= {:?}", deseralied_edge1);
392 | 
393 |         let _jsoncanvas_deserialized: JsonCanvas = serialized_canvas.parse().unwrap();
394 |     }
395 | }
396 | 


--------------------------------------------------------------------------------
/src/node/file.rs:
--------------------------------------------------------------------------------
 1 | use std::path::PathBuf;
 2 | 
 3 | use crate::NodeId;
 4 | use crate::{color::Color, PixelCoordinate, PixelDimension};
 5 | 
 6 | use super::ambassador_impl_GenericNodeInfo;
 7 | use super::{GenericNode, GenericNodeInfo};
 8 | use ambassador::Delegate;
 9 | use serde::{Deserialize, Serialize};
10 | 
11 | #[derive(Debug, Delegate, Serialize, Deserialize)]
12 | #[delegate(GenericNodeInfo, target = "generic")]
13 | pub struct FileNode {
14 |     #[serde(flatten)]
15 |     generic: GenericNode,
16 |     file: PathBuf,
17 |     #[serde(skip_serializing_if = "Option::is_none")]
18 |     subpath: Option<String>,
19 | }
20 | 
21 | impl FileNode {
22 |     #[allow(clippy::too_many_arguments)]
23 |     pub fn new(
24 |         id: NodeId,
25 |         x: PixelCoordinate,
26 |         y: PixelCoordinate,
27 |         width: PixelDimension,
28 |         height: PixelDimension,
29 |         color: Option<Color>,
30 |         file: PathBuf,
31 |         subpath: Option<String>,
32 |     ) -> Self {
33 |         Self {
34 |             generic: GenericNode::new(id, x, y, width, height, color),
35 |             file,
36 |             subpath,
37 |         }
38 |     }
39 | 
40 |     pub fn file(&self) -> &PathBuf {
41 |         &self.file
42 |     }
43 | 
44 |     pub fn subpath(&self) -> Option<&String> {
45 |         self.subpath.as_ref()
46 |     }
47 | }
48 | 


--------------------------------------------------------------------------------
/src/node/group.rs:
--------------------------------------------------------------------------------
 1 | use std::path::PathBuf;
 2 | 
 3 | use ambassador::Delegate;
 4 | use serde::{Deserialize, Serialize};
 5 | 
 6 | use crate::NodeId;
 7 | use crate::{color::Color, PixelCoordinate, PixelDimension};
 8 | 
 9 | use super::ambassador_impl_GenericNodeInfo;
10 | use super::{GenericNode, GenericNodeInfo};
11 | 
12 | #[derive(Debug, Delegate, Serialize, Deserialize)]
13 | #[delegate(GenericNodeInfo, target = "generic")]
14 | pub struct GroupNode {
15 |     #[serde(flatten)]
16 |     generic: GenericNode,
17 |     #[serde(skip_serializing_if = "Option::is_none")]
18 |     label: Option<String>,
19 |     #[serde(skip_serializing_if = "Option::is_none")]
20 |     #[serde(flatten)]
21 |     background: Option<Background>,
22 | }
23 | 
24 | impl GroupNode {
25 |     #[allow(clippy::too_many_arguments)]
26 |     pub fn new(
27 |         id: NodeId,
28 |         x: PixelCoordinate,
29 |         y: PixelCoordinate,
30 |         width: PixelDimension,
31 |         height: PixelDimension,
32 |         color: Option<Color>,
33 |         label: Option<String>,
34 |         background: Option<Background>,
35 |     ) -> Self {
36 |         Self {
37 |             generic: GenericNode::new(id, x, y, width, height, color),
38 |             label,
39 |             background,
40 |         }
41 |     }
42 | 
43 |     pub fn label(&self) -> Option<&String> {
44 |         self.label.as_ref()
45 |     }
46 | 
47 |     pub fn background(&self) -> Option<&Background> {
48 |         self.background.as_ref()
49 |     }
50 | }
51 | 
52 | #[derive(Debug, Serialize, Deserialize)]
53 | #[serde(rename_all = "camelCase")]
54 | pub struct Background {
55 |     image: PathBuf,
56 |     #[serde(skip_serializing_if = "Option::is_none")]
57 |     background_style: Option<BackgroundStyle>,
58 | }
59 | 
60 | impl Background {
61 |     pub fn new(image: PathBuf, background_style: Option<BackgroundStyle>) -> Background {
62 |         Background {
63 |             image,
64 |             background_style,
65 |         }
66 |     }
67 | }
68 | 
69 | #[derive(Debug, Serialize, Deserialize)]
70 | #[serde(rename_all = "camelCase")]
71 | pub enum BackgroundStyle {
72 |     Cover,
73 |     Ratio,
74 |     Repeat,
75 | }
76 | 


--------------------------------------------------------------------------------
/src/node/link.rs:
--------------------------------------------------------------------------------
 1 | use ambassador::Delegate;
 2 | use serde::{Deserialize, Serialize};
 3 | pub use url::Url;
 4 | 
 5 | use crate::NodeId;
 6 | use crate::{color::Color, PixelCoordinate, PixelDimension};
 7 | 
 8 | use super::ambassador_impl_GenericNodeInfo;
 9 | use super::{GenericNode, GenericNodeInfo};
10 | 
11 | #[derive(Debug, Delegate, Serialize, Deserialize)]
12 | #[delegate(GenericNodeInfo, target = "generic")]
13 | pub struct LinkNode {
14 |     #[serde(flatten)]
15 |     generic: GenericNode,
16 |     url: Url,
17 | }
18 | 
19 | impl LinkNode {
20 |     pub fn new(
21 |         id: NodeId,
22 |         x: PixelCoordinate,
23 |         y: PixelCoordinate,
24 |         width: PixelDimension,
25 |         height: PixelDimension,
26 |         color: Option<Color>,
27 |         url: Url,
28 |     ) -> Self {
29 |         Self {
30 |             generic: GenericNode::new(id, x, y, width, height, color),
31 |             url,
32 |         }
33 |     }
34 | 
35 |     pub fn url(&self) -> &Url {
36 |         &self.url
37 |     }
38 | }
39 | 


--------------------------------------------------------------------------------
/src/node/mod.rs:
--------------------------------------------------------------------------------
  1 | use crate::color::Color;
  2 | use crate::NodeId;
  3 | use crate::PixelCoordinate;
  4 | use crate::PixelDimension;
  5 | use ambassador::{delegatable_trait, Delegate};
  6 | use serde::{Deserialize, Serialize};
  7 | 
  8 | mod file;
  9 | mod group;
 10 | mod link;
 11 | mod text;
 12 | 
 13 | pub use file::FileNode;
 14 | pub use group::{Background, BackgroundStyle, GroupNode};
 15 | pub use link::LinkNode;
 16 | pub use text::TextNode;
 17 | 
 18 | #[derive(Debug, Serialize, Deserialize)]
 19 | pub struct GenericNode {
 20 |     pub id: NodeId,
 21 |     x: PixelCoordinate,
 22 |     y: PixelCoordinate,
 23 |     width: PixelDimension,
 24 |     height: PixelDimension,
 25 |     #[serde(skip_serializing_if = "Option::is_none")]
 26 |     color: Option<crate::color::Color>,
 27 | }
 28 | 
 29 | impl GenericNode {
 30 |     pub fn new(
 31 |         id: NodeId,
 32 |         x: PixelCoordinate,
 33 |         y: PixelCoordinate,
 34 |         width: PixelDimension,
 35 |         height: PixelDimension,
 36 |         color: Option<Color>,
 37 |     ) -> Self {
 38 |         Self {
 39 |             id,
 40 |             x,
 41 |             y,
 42 |             width,
 43 |             height,
 44 |             color,
 45 |         }
 46 |     }
 47 | }
 48 | 
 49 | #[delegatable_trait]
 50 | pub trait GenericNodeInfo {
 51 |     fn id(&self) -> &NodeId;
 52 |     fn get_x(&self) -> PixelCoordinate;
 53 |     fn get_y(&self) -> PixelCoordinate;
 54 |     fn get_width(&self) -> PixelDimension;
 55 |     fn get_height(&self) -> PixelDimension;
 56 |     fn color(&self) -> &Option<Color>;
 57 | }
 58 | 
 59 | // This must come below the #[delegatable_trait] trait; see
 60 | // https://github.com/hobofan/ambassador/issues/45#issuecomment-1901574140
 61 | pub use ambassador_impl_GenericNodeInfo;
 62 | 
 63 | impl GenericNodeInfo for GenericNode {
 64 |     fn id(&self) -> &NodeId {
 65 |         &self.id
 66 |     }
 67 | 
 68 |     fn get_x(&self) -> PixelCoordinate {
 69 |         self.x
 70 |     }
 71 | 
 72 |     fn get_y(&self) -> PixelCoordinate {
 73 |         self.y
 74 |     }
 75 | 
 76 |     fn get_width(&self) -> PixelDimension {
 77 |         self.width
 78 |     }
 79 | 
 80 |     fn get_height(&self) -> PixelDimension {
 81 |         self.height
 82 |     }
 83 | 
 84 |     fn color(&self) -> &Option<Color> {
 85 |         &self.color
 86 |     }
 87 | }
 88 | 
 89 | #[derive(Debug, Delegate, Serialize, Deserialize)]
 90 | #[delegate(GenericNodeInfo)]
 91 | #[serde(tag = "type", rename_all = "camelCase")]
 92 | pub enum Node {
 93 |     Text(TextNode),
 94 |     File(FileNode),
 95 |     Link(LinkNode),
 96 |     Group(GroupNode),
 97 | }
 98 | 
 99 | impl From<GroupNode> for Node {
100 |     fn from(node: GroupNode) -> Self {
101 |         Node::Group(node)
102 |     }
103 | }
104 | 
105 | impl From<TextNode> for Node {
106 |     fn from(node: TextNode) -> Self {
107 |         Node::Text(node)
108 |     }
109 | }
110 | 
111 | impl From<FileNode> for Node {
112 |     fn from(node: FileNode) -> Self {
113 |         Node::File(node)
114 |     }
115 | }
116 | 
117 | impl From<LinkNode> for Node {
118 |     fn from(node: LinkNode) -> Self {
119 |         Node::Link(node)
120 |     }
121 | }
122 | 


--------------------------------------------------------------------------------
/src/node/text.rs:
--------------------------------------------------------------------------------
 1 | use ambassador::Delegate;
 2 | use serde::{Deserialize, Serialize};
 3 | 
 4 | use crate::NodeId;
 5 | use crate::{color::Color, PixelCoordinate, PixelDimension};
 6 | 
 7 | use super::ambassador_impl_GenericNodeInfo;
 8 | use super::{GenericNode, GenericNodeInfo};
 9 | 
10 | #[derive(Debug, Delegate, Serialize, Deserialize)]
11 | #[delegate(GenericNodeInfo, target = "generic")]
12 | pub struct TextNode {
13 |     #[serde(flatten)]
14 |     generic: GenericNode,
15 |     text: String,
16 | }
17 | 
18 | impl TextNode {
19 |     pub fn new(
20 |         id: NodeId,
21 |         x: PixelCoordinate,
22 |         y: PixelCoordinate,
23 |         width: PixelDimension,
24 |         height: PixelDimension,
25 |         color: Option<Color>,
26 |         text: String,
27 |     ) -> Self {
28 |         Self {
29 |             generic: GenericNode::new(id, x, y, width, height, color),
30 |             text,
31 |         }
32 |     }
33 | 
34 |     pub fn text(&self) -> &str {
35 |         &self.text
36 |     }
37 | }
38 | 


---------------------------------------------------------